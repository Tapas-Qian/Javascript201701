<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>call&apply</title>
    <!---->
    <link rel="stylesheet" href="../plugs/.adf.css">
    <script src="../plugs.adfa.js"></script>
    <!---->
</head>
<body>
</body>
</html>
<script>
    'use strict'; // js代码按照严格模式解析

    /*
    *   严格模式和非严格模式区别 :  百度...
    *       1 call方法使用如果把this修改成null，在严格模式下就是null，非严格window
    *       2 自运行函数中的this，严格模式下是undefined,非严格window
    *       3 函数执行中的this如果前面没有".",严格模式下是undefiend,非严格window
    *
    * */

    /*
    *   call,apply,bind 方法的作用 :
    *
    *        定义位置 ： 定义在Function.prototype上。相对于每个Function类实例来说都是公有方法。=> 每个函数都可以调用call,apply,bind方法
    *
    *       call 用法 :
    *           1) : 先获取到定义在Function原型上的call方法
    *           2) : 然后把调用call方法的这个函数(实例)中的this修改成call的第一个参数
    *           3) : 调用call方法的这个函数执行
    *           ps : call从第二个参数开始是传给调用call方法的函数实例的
    *           ps : 调用过call方法之后的函数也是执行过的
    *
    *       apply 用法 :
    *           和call的用法基本相同，第一个参数都是用来修改this的，第二个参数是一个数组，是把数组里的每一项当作参数传给调用apply的那个函数的
    *           ps : 和call一样，只要apply执行过了相当于调用apply的函数也执行了
    *
    *       bind 用法 : 和call、apply最大区别就是没有把调用bind的函数直接执行，返回了一个修改好this的新函数。返回的新函数还可以继续执行。  不兼容
    *
    *
    * */
    function sum(num1,num2){
        console.log(this);
        console.log(num1 + num2);
    }
    //sum.call(null,100,200);
    //sum.apply(document,[100,200]);
    var res = sum.bind(document);
    res(100,200);
    res(300,400);





</script>